* [redis](#redis)
   * [数据结构](#数据结构)
      * [字符串](#字符串)
      * [哈希表](#哈希表)
      * [列表](#列表)
      * [集合](#集合)
      * [有序集合](#有序集合)
      * [其他](#其他)
   * [小功能](#小功能)
   * [客户端问题](#客户端问题)
   * [持久化](#持久化)
   * [复制](#复制)
   * [阻塞](#阻塞)
   * [内存](#内存)
   * [哨兵](#哨兵)
   * [集群](#集群)
   * [缓存](#缓存)
   * [开发运维](#开发运维)

# redis

## 数据结构
![image](https://user-images.githubusercontent.com/6240382/151688527-56d616a4-0542-40f8-9542-2f6e88350090.png)


### 字符串

- setnx可以作为分布式锁的实现方法；
- 内部编码
```

字符串类型的内部编码有3种：

·int：8个字节的长整型。

·embstr：小于等于39个字节的字符串。

·raw：大于39个字节的字符串。

Redis会根据当前值的类型和长度决定使用哪种内部编码实现。


```


### 哈希表


- 内部编码

```

- ziplist
- hashtable

当field个数比较少且没有大的value时，内部编码为ziplist：
当有value大于64字节，内部编码会由ziplist变为hashtable：
当field个数超过512，内部编码也会由ziplist变为hashtable：



```

- ziplist
![image](https://user-images.githubusercontent.com/6240382/151689421-f802292e-4de9-4fe9-85cf-5dddb1dee9a3.png)

- 场景
    - 复杂api频控 


### 列表

- 内部编码
```


- ziplist
- linkedlist

当元素个数较少且没有大元素时，内部编码为ziplist
当元素个数超过512个，内部编码变为linkedlist：
或者当某个元素超过64字节，内部编码也会变为linkedlist：



```

- 场景
    - lpush+lpop=Stack（栈）
    - lpush+rpop=Queue（队列）
    - lpsh+ltrim=Capped Collection（有限集合）
    - lpush+brpop=Message Queue（消息队列）

### 集合

- 内部编码
```


- intset
- hashtable


当元素个数较少且都为整数时，内部编码为intset：
当元素个数超过512个，内部编码变为hashtable：
当某个元素不为整数时，内部编码也会变为hashtable：


```
- 场景
    - 用户标签
    - spop/srandmember=Random item（生成随机数，比如抽奖）
    - sadd+sinter=Social Graph（社交需求）
    
### 有序集合

- 内部编码

```

ziplist
skiplist

当元素个数较少且每个元素较小时，内部编码为ziplist：
当元素个数超过128个，内部编码变为skiplist：
当某个元素大于64字节时，内部编码也会变为hashtable：


```

- skiplist
![image](https://user-images.githubusercontent.com/6240382/151689444-5cb681b0-cd16-4103-9be3-96dc036bd654.png)
    - 数据结构
        - 表头（head）：负责维护跳跃表的节点指针。
        - 跳跃表节点：保存着元素值，以及多个层。
        - 层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。
        - 表尾：全部由 NULL 组成，表示跳跃表的末尾。
    - 跳跃表是一种随机化数据结构，查找、添加、删除操作都可以在对数期望时间下完成。
    - 跳跃表目前在 Redis 的唯一作用，就是作为有序集类型的底层数据结构（之一，另一个构成有序集的结构是字典）。
    - 为了满足自身的需求，Redis 基于 William Pugh 论文中描述的跳跃表进行了修改，包括：
        - score 值可重复。
        - 对比一个元素需要同时检查它的 score 和 memeber 。
        - 每个节点带有高度为 1 层的后退指针，用于从表尾方向向表头方向迭代。


- 场景
    - 排行榜
### 其他
- 纯内存存储、IO多路复用技术、单线程架构是造就Redis高性能的三个因素
- 由于Redis的单线程架构，所以需要每个命令能被快速执行完，否则会存在阻塞Redis的可能，理解Redis单线程命令处理机制是开发和运维Redis的核心之一。
- move、dump+restore、migrate是Redis发展过程中三种迁移键的方式，其中move命令基本废弃，migrate命令用原子性的方式实现了dump+restore，并且支持批量操作，是Redis Cluster实现水平扩容的重要工具。
- scan命令可以解决keys命令可能带来的阻塞问题，同时Redis还提供了hscan、sscan、zscan渐进式地遍历hash、set、zset。

## 小功能

### 慢日志
- 由于慢查询日志是一个先进先出的队列，也就是说如果慢查询比较多的情况下，可能会丢失部分慢查询命令，为了防止这种情况发生，可以定期执行slow get命令将慢查询日志持久化

### pipeline+事务+lua
- pipeline就是批量执行，非原子操作；
- 事务不支持回滚，语法错误才能导致失败，否则执行部分；
- lua可加载脚本，按唯一id进行执行，提高效率；

### bitmap
- 节省内存，用于统计日活等数据；

### HyperLogLog
- 节省内存，用于统计大概日活，存在一定误差；（类似布隆过滤）

### GEO
- 地理位置存储，使用有序集合


## 客户端问题

### redis内存陡增
- 现象：主节点内存突增，从节点不变；
- info clients查询关键指标，如client_longest_output_list
- client list查看链接信息，如omem
- 执行client kill
- 原因是客户端有人执如monitor等耗内存操作，或者bigkey

### redis客户端超时
- 慢查询
- big key或者耗时操作


## 持久化


### rdb
- bgsave流程
![image](https://user-images.githubusercontent.com/6240382/152909212-18fd6875-e3f7-46f7-a84c-21347526e6a3.png)

1）执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回。

2）父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒。

3）父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。

4）子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项。

5）进程发送信号给父进程表示完成，父进程更新统计信息，具体见info Persistence下的rdb_*相关选项。

- 优缺点
> RDB的优点

·RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。

·Redis加载RDB恢复数据远远快于AOF的方式。

> RDB的缺点


    
·RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。

·RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。

·针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。



### aof
- 流程
![image](https://user-images.githubusercontent.com/6240382/152910774-2b747976-a1bb-4393-aa2d-8dde4fb298ca.png)

1）所有的写入命令会追加到aof_buf（缓冲区）中。

2）AOF缓冲区根据对应的策略向硬盘做同步操作。

3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。

4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。

- 当触发AOF重写时

![image](https://user-images.githubusercontent.com/6240382/152911263-fa7e362f-248a-4341-8b27-c7dceaf68d71.png)

1）执行AOF重写请求。

如果当前进程正在执行AOF重写，请求不执行并返回如下响应：
ERR Background append only file rewriting already in progress
如果当前进程正在执行bgsave操作，重写命令延迟到bgsave完成之后再执行，返回如下响应：
Background append only file rewriting scheduled

2）父进程执行fork创建子进程，开销等同于bgsave过程。

3.1）主进程fork操作完成后，继续响应其他命令。所有修改命令依然写入AOF缓冲区并根据appendfsync策略同步到硬盘，保证原有AOF机制正确性。

3.2）由于fork操作运用写时复制技术，子进程只能共享fork操作时的内存数据。由于父进程依然响应命令，Redis使用“AOF重写缓冲区”保存这部分新数据，防止新AOF文件生成期间丢失这部分数据。

4）子进程根据内存快照，按照命令合并规则写入到新的AOF文件。每次批量写入硬盘数据量由配置aof-rewrite-incremental-fsync控制，默认为32MB，防止单次刷盘数据过多造成硬盘阻塞。

5.1）新AOF文件写入完成后，子进程发送信号给父进程，父进程更新统计信息，具体见info persistence下的aof_*相关统计。

5.2）父进程把AOF重写缓冲区的数据写入到新的AOF文件。

5.3）使用新AOF文件替换老文件，完成AOF重写。

- 总结

6）子进程执行期间使用copy-on-write机制与父进程共享内存，避免内存消耗翻倍。AOF重写期间还需要维护重写缓冲区，保存新的写入命令避免数据丢失。

7）持久化阻塞主线程场景有：fork阻塞和AOF追加阻塞。fork阻塞时间跟内存量和系统有关，AOF追加阻塞说明硬盘资源紧张。

8）单机下部署多个实例时，为了防止出现多个子进程执行重写操作，建议做隔离控制，避免CPU和IO资源竞争。

## 复制

1）Redis通过复制功能实现主节点的多个副本。从节点可灵活地通过slaveof命令建立或断开复制流程。

2）复制支持树状结构，从节点可以复制另一个从节点，实现一层层向下的复制流。Redis2.8之后复制的流程分为：全量复制和部分复制。全量复制需要同步全部主节点的数据集，大量消耗机器和网络资源。而部分复制有效减少因网络异常等原因造成的不必要全量复制情况。通过配置合理的复制积压缓冲区尽量避免全量复制。

3）主从节点之间维护心跳和偏移量检查机制，保证主从节点通信正常和数据一致。

4）Redis为了保证高性能复制过程是异步的，写命令处理完后直接返回给客户端，不等待从节点复制完成。因此从节点数据集会有延迟情况。

5）当使用从节点用于读写分离时会存在数据延迟、过期数据、从节点可用性等问题，需要根据自身业务提前作出规避。

6）在运维过程中，主节点存在多个从节点或者一台机器上部署大量主节点的情况下，会有复制风暴的风险。

## 阻塞

1）客户端最先感知阻塞等Redis超时行为，加入日志监控报警工具可快速定位阻塞问题，同时需要对Redis进程和机器做全面监控。

2）阻塞的内在原因：确认主线程是否存在阻塞，检查慢查询等信息，发现不合理使用API或数据结构的情况，如keys、sort、hgetall等。关注CPU使用率防止单核跑满。当硬盘IO资源紧张时，AOF追加也会阻塞主线程。

3）阻塞的外在原因：从CPU竞争、内存交换、网络问题等方面入手排查是否因为系统层面问题引起阻塞。

## 内存

1）Redis实际内存消耗主要包括：键值对象、缓冲区内存、内存碎片。

2）通过调整maxmemory控制Redis最大可用内存。当内存使用超出时，根据maxmemory-policy控制内存回收策略。

3）内存是相对宝贵的资源，通过合理的优化可以有效地降低内存的使用量，内存优化的思路包括：

·精简键值对大小，键值字面量精简，使用高效二进制序列化工具。

·使用对象共享池优化小整数对象。

·数据优先使用整数，比字符串类型更节省空间。

·优化字符串使用，避免预分配造成的内存浪费。

·使用ziplist压缩编码优化hash、list等结构，注重效率和空间的平衡。

·使用intset编码优化整数集合。

·使用ziplist编码的hash结构降低小对象链规模。

## 哨兵

1）Redis Sentinel是Redis的高可用实现方案：故障发现、故障自动转移、配置中心、客户端通知。

2）Redis Sentinel从Redis2.8版本开始才正式生产可用，之前版本生产不可用。

3）尽可能在不同物理机上部署Redis Sentinel所有节点。

4）Redis Sentinel中的Sentinel节点个数应该为大于等于3且最好为奇数。

5）Redis Sentinel中的数据节点与普通数据节点没有区别。

6）客户端初始化时连接的是Sentinel节点集合，不再是具体的Redis节点，但Sentinel只是配置中心不是代理。

7）Redis Sentinel通过三个定时任务实现了Sentinel节点对于主节点、从节点、其余Sentinel节点的监控。

8）Redis Sentinel在对节点做失败判定时分为主观下线和客观下线。

9）看懂Redis Sentinel故障转移日志对于Redis Sentnel以及问题排查非常有帮助。

10）Redis Sentinel实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis数据节点的状态变化。


## 集群

1）Redis集群数据分区规则采用虚拟槽方式，所有的键映射到16384个槽中，每个节点负责一部分槽和相关数据，实现数据和请求的负载均衡。

2）搭建集群划分三个步骤：准备节点，节点握手，分配槽。可以使用redis-trib.rb create命令快速搭建集群。

3）集群内部节点通信采用Gossip协议彼此发送消息，消息类型分为：ping消息、pong消息、meet消息、fail消息等。节点定期不断发送和接受ping/pong消息来维护更新集群的状态。消息内容包括节点自身数据和部分其他节点的状态数据。

4）集群伸缩通过在节点之间移动槽和相关数据实现。扩容时根据槽迁移计划把槽从源节点迁移到目标节点，源节点负责的槽相比之前变少从而达到集群扩容的目的，收缩时如果下线的节点有负责的槽需要迁移到其他节点，再通过cluster forget命令让集群内其他节点忘记被下线节点。

5）使用Smart客户端操作集群达到通信效率最大化，客户端内部负责计算维护键→槽→节点的映射，用于快速定位键命令到目标节点。集群协议通过Smart客户端全面高效的支持需要一个过程，用户在选择Smart客户端时建议review下集群交互代码如：异常判定和重试逻辑，更新槽的并发控制等。节点接收到键命令时会判断相关的槽是否由自身节点负责，如果不是则返回重定向信息。重定向分为MOVED和ASK，ASK说明集群正在进行槽数据迁移，客户端只在本次请求中做临时重定向，不会更新本地槽缓存。MOVED重定向说明槽已经明确分派到另一个节点，客户端需要更新槽节点缓存。

6）集群自动故障转移过程分为故障发现和故障恢复。节点下线分为主观下线和客观下线，当超过半数主节点认为故障节点为主观下线时标记它为客观下线状态。从节点负责对客观下线的主节点触发故障恢复流程，保证集群的可用性。

7）开发和运维集群过程中常见问题包括：超大规模集群带宽消耗，pub/sub广播问题，集群节点倾斜问题，手动故障转移，在线迁移数据等。





## 缓存

1）缓存的使用带来的收益是能够加速读写，降低后端存储负载。

2）缓存的使用带来的成本是缓存和存储数据不一致性，代码维护成本增大，架构复杂度增大。

3）比较推荐的缓存更新策略是结合剔除、超时、主动更新三种方案共同完成。

4）穿透问题：使用缓存空对象和布隆过滤器来解决，注意它们各自的使用场景和局限性。

5）无底洞问题：分布式缓存中，有更多的机器不保证有更高的性能。有四种批量操作方式：串行命令、串行IO、并行IO、hash_tag。

6）雪崩问题：缓存层高可用、客户端降级、提前演练是解决雪崩问题的重要方法。

7）热点key问题：互斥锁、“永远不过期”能够在一定程度上解决热点key问题，开发人员在使用时要了解它们各自的使用成本。



## 开发运维

1）Linux相关优化：

·vm.overcommit_memory建议为1。

·Linux>3.5，vm.swappiness建议为1，否则建议为0。

·Transparent Huge Pages（THP）建议关闭掉，但需要注意Linux发行版本改变了THP的配置位置。

·可以为Redis进程设置oom_adj，减少Redis被OOM killer杀掉的概率，但不要过度依赖此特性。

·建议对Redis所有节点所在机器使用NTP服务。

·设置合理的ulimit保证网络连接正常。

·设置合理的tcp-backlog参数。

2）理解Redis的持久化有助于解决flush操作之后的数据快速恢复问题。

3）Redis安全建议：

·根据具体网络环境决定是否设置Redis密码。

·rename-command可以伪装命令，但是要注意成本。

·合理的防火墙是防止攻击的利器。

·bind可以将Redis的访问绑定到指定网卡上。

·定期备份数据应该作为习惯性操作。

·可以适当错开Redis默认端口启动。

·使用非root用户启动Redis。

4）bigkey的危害不容忽视：数据倾斜、超时阻塞、网络拥塞，可能是Redis生产环境中的一颗定时炸弹，删除bigkey时通常使用渐进式遍历的方式，防止出现Redis阻塞的情况。

5）通过客户端、代理、monitor、机器抓包四种方式找到热点key，这几种方式各具优势，具体使用哪种要根据当前场景来决定。












